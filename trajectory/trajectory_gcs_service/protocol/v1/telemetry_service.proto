syntax = "proto3";

package trajectory.trajectory_gcs_service.protocol.v1;
option go_package = "github.com/trajectoryjp/trjx_api_service/trajectory_gcs";


import "trajectory/trajectory_gcs_service/protocol/v1/resource.proto";
import "trajectory/type/resource.proto";

service TelemetryService {

    // GetMobilityPositions: å¯¾è±¡ç¯„å›²ã«ã‚ã‚‹æ©Ÿä½“ã®ä½ç½®æƒ…å ±ã‚’å–å¾—ã™ã‚‹
    rpc GetMobilityPositions(GetMobilityPositionsRequest) returns (stream MobilityPosition) {}

    // UAVã®ãƒ«ãƒ¼ãƒˆé€¸è„±çŠ¶æ…‹é€šçŸ¥
    rpc NotifyDeviation(NotifyDeviationRequest) returns (stream NotifyDeviationResponse) {}
}


message GetMobilityPositionsRequest {
    oneof ReferencePosition { // æ¤œçŸ¥è·é›¢ã®åŸºæº–ä½ç½®
        UAVID uav_id = 1; // æ™‚çµ„ç¹”æ©Ÿä½“IDã€€ä»–çµ„ç¹”ã‚’æŒ‡å®šã—ãŸå ´åˆã¯ã‚¨ãƒ©ãƒ¼
        int32 user_index = 2; // publish positionã§é€šçŸ¥ã•ã‚Œã‚‹ID
        trajectory.trjx_api_service.Position position = 3; // åº§æ¨™
    }

    trajectory.trjx_api_service.Standard output_altitude = 6; // å‡ºåŠ›ä½ç½®ã®é«˜åº¦å±æ€§
    
    oneof DetectionMethod {
        float horizontal_distance = 11; // æ°´å¹³è·é›¢(m)
        DetectThreeDimensions three_dimensions = 12; // 3Dè·é›¢
    }
    
    enum OutputRange { // è¦å‰Šé™¤ğŸŸ¥ spec249_1-BGè¨­è¨ˆæ›¸ã®ToDo(2) WideGetPositionã«outputRangeã‚­ãƒ£ãƒƒã‚·ãƒ¥æ©Ÿèƒ½å®Ÿè£…æ¸ˆã¿ã®ãŸã‚è¿½åŠ ã—ã¦è‰¯ã„ã‹ï¼Ÿ ğŸŸ¥
        OUTPUT_RANGE_UNSPECIFIED = 0; // è‡ªçµ„ç¹”ãƒ»ä»–çµ„ç¹”ã®æ©Ÿä½“
        EXCLUDE_OWN_ORGANIZATION = 1; // ä»–çµ„ç¹”ã®æ©Ÿä½“ã®ã¿
    }
    optional OutputRange output_range = 4; // å‡ºåŠ›å¯¾è±¡ã€€çœç•¥ã—ãŸå ´åˆã€è‡ªçµ„ç¹”ãƒ»ä»–çµ„ç¹”ã®æ©Ÿä½“
}

message DetectThreeDimensions {
    float distance = 1; // è·é›¢(m)
    bool collision = 2; // trueã®å ´åˆã€è¡çªå¯èƒ½æ€§ãŒã‚ã‚‹ã‚‚ã®ã®ã¿ã‚’é€šçŸ¥
}

message MobilityPosition {
    ReferencePosition reference_position = 1; // åŸºæº–åº§æ¨™
    string public_uav_id = 2; // æŒ‡å®šç¯„å›²æ¡ä»¶ã«ä¸€è‡´ã™ã‚‹å¤–éƒ¨æ©Ÿä½“ID
    string uav_name = 3; // æ©Ÿä½“å
    optional string remote_id = 4; // ãƒªãƒ¢ãƒ¼ãƒˆID
    float distance = 5; // è·é›¢(m)
    bool collisionCourse = 6; // è¡çªã‚³ãƒ¼ã‚¹ã®å ´åˆã€true
    Approaching approach = 7; // ç›¸å¯¾ä½ç½®ãŠã‚ˆã³é€Ÿåº¦
    AbsolutePosition collisionPoint = 8;
    float heading = 9;
}

message Approaching {
    XYZPosition relative_position = 1;
    AbsolutePosition absolute_position = 3;
    PredictSpeed relative_speed = 2 ;
}

message AbsolutePosition{
    double latitude = 1;
    double longitude = 2;
    double altitude = 3;
    string tag = 4; //ãƒŸãƒƒã‚·ãƒ§ãƒ³è­˜åˆ¥å­ã€‚GetETAã§åˆ©ç”¨ã—ã¦ã„ã‚‹
}

message ReferencePosition {
    // Attribute_xxã€€ã«å¤‰æ›´
    // enum Attribute {
    //     man = 0 ;
    //     unmannedVehicle = 1;
    //     car = 2;
    //     ship = 3;
    //     airplane =4;
    //     helicopter =5;
    //     marker =6;
    //     train = 7 ;
    // }
    trajectory.trjx_api_service.UserType user_type = 1;

    trajectory.trjx_api_service.Position position = 2;
}

message XYZPosition {
    // çµŒåº¦æ–¹å‘è·é›¢(m)ã€€åŒ—ï¼‹
     double y = 1;   
    // ç·¯åº¦æ–¹å‘è·é›¢(m)ã€€æ±ï¼‹
    double x = 2;
    // é«˜ã•è·é›¢(m) å³æ‰‹ç³» ä¸Š+
    double z = 3;
}

message PredictSpeed {
    // çµŒåº¦æ–¹å‘é€Ÿåº¦(m/sec)
    double x = 1;
    // ç·¯åº¦æ–¹å‘é€Ÿåº¦(m/sec)
    double y = 2;
    // ä¸Šæ˜‡é€Ÿåº¦(m/sec) å³æ‰‹ç³»
    double z = 3;
}

message NotifyDeviationRequest{
    UAVID uav_id = 1;
}

message NotifyDeviationResponse{
    bool deviates_course = 1; // é€¸è„±ã®å ´åˆtrue
}